# Agave Platform Science API
#
# Power your digital lab and reduce the time from theory to discovery using the Agave Science-as-a-Service API Platform. Agave provides hosted services that allow researchers to manage data, conduct experiments, and publish and share results from anywhere at any time.
#
# Agave Platform version: 2.2.14
# 
# Generated by: https://github.com/swagger-api/swagger-codegen.git


#' JobSubmission Class
#'
#' This represents the request made to the Agave jobs api to run a registered application.
#'
#' @field archive Whether the output from this job should be archived. If true, all new files created by this application&#39;s execution will be archived to the archivePath in the user&#39;s default storage system.
#' @field archivePath The path of the archive folder for this job on the archiveSystem. Defaults to default storage system of the user
#' @field archiveSystem The system on which the job data will be archived
#' @field inputs The application specific input files needed for this job. These vary from application to application and should be entered as multiple individual parameters in the form. Inputs may be given as relative paths in the user&#39;s default storage system or as URI. If a URI is given, the data will be staged in by the IO service and made avaialble to the application at run time.
#' @field name The name of the job.
#' @field maxMemory The maximum amount of memory needed for this application to run given in GB.
#' @field nodeCount The number of nodes this application should utilize while running. If the application is not of executionType PARALLEL, this should be 1.
#' @field notifications An array of notifications you wish to receive.
#' @field parameters The application specific parameters needed for this job. These vary from application to application and should be entered as multiple individual parameters in the form. The actual dataType will be determined by the application description.
#' @field processorsPerNode The number of processors this application should utilize while running.
#' @field batchQueue The queue to which this job should be submitted. This is optional and only applies when the execution system has a batch scheduler.
#' @field maxRunTime The estimated compute time needed for this application to complete given in hh:mm:ss format.
#' @field appId The unique name of the application being run by this job. This must be a valid application that the calling user has permission to run.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
JobSubmission <- R6::R6Class(
  'JobSubmission',
  public = list(
    `archive` = NULL,
    `archivePath` = NULL,
    `archiveSystem` = NULL,
    `inputs` = NULL,
    `name` = NULL,
    `maxMemory` = NULL,
    `nodeCount` = NULL,
    `notifications` = NULL,
    `parameters` = NULL,
    `processorsPerNode` = NULL,
    `batchQueue` = NULL,
    `maxRunTime` = NULL,
    `appId` = NULL,
    initialize = function(`archive`, `archivePath`, `archiveSystem`, `inputs`, `name`, `maxMemory`, `nodeCount`, `notifications`, `parameters`, `processorsPerNode`, `batchQueue`, `maxRunTime`, `appId`){
      if (!missing(`archive`)) {
        self$`archive` <- `archive`
      }
      if (!missing(`archivePath`)) {
        stopifnot(is.character(`archivePath`), length(`archivePath`) == 1)
        self$`archivePath` <- `archivePath`
      }
      if (!missing(`archiveSystem`)) {
        stopifnot(is.character(`archiveSystem`), length(`archiveSystem`) == 1)
        self$`archiveSystem` <- `archiveSystem`
      }
      if (!missing(`inputs`)) {
        stopifnot(is.character(`inputs`), length(`inputs`) == 1)
        self$`inputs` <- `inputs`
      }
      if (!missing(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!missing(`maxMemory`)) {
        stopifnot(is.character(`maxMemory`), length(`maxMemory`) == 1)
        self$`maxMemory` <- `maxMemory`
      }
      if (!missing(`nodeCount`)) {
        stopifnot(is.numeric(`nodeCount`), length(`nodeCount`) == 1)
        self$`nodeCount` <- `nodeCount`
      }
      if (!missing(`notifications`)) {
        stopifnot(is.list(`notifications`), length(`notifications`) != 0)
        lapply(`notifications`, function(x) stopifnot(R6::is.R6(x)))
        self$`notifications` <- `notifications`
      }
      if (!missing(`parameters`)) {
        stopifnot(R6::is.R6(`parameters`))
        self$`parameters` <- `parameters`
      }
      if (!missing(`processorsPerNode`)) {
        stopifnot(is.numeric(`processorsPerNode`), length(`processorsPerNode`) == 1)
        self$`processorsPerNode` <- `processorsPerNode`
      }
      if (!missing(`batchQueue`)) {
        stopifnot(is.character(`batchQueue`), length(`batchQueue`) == 1)
        self$`batchQueue` <- `batchQueue`
      }
      if (!missing(`maxRunTime`)) {
        stopifnot(is.character(`maxRunTime`), length(`maxRunTime`) == 1)
        self$`maxRunTime` <- `maxRunTime`
      }
      if (!missing(`appId`)) {
        stopifnot(is.character(`appId`), length(`appId`) == 1)
        self$`appId` <- `appId`
      }
    },
    asJSON = function() {
      self$toJSON()
    },
    toJSON = function() {
      JobSubmissionObject <- list()
      if (!is.null(self$`archive`)) {
        JobSubmissionObject[['archive']] <- self$`archive`
      }
      else {
        JobSubmissionObject[['archive']] <- NULL
      }
      if (!is.null(self$`archivePath`)) {
        JobSubmissionObject[['archivePath']] <- self$`archivePath`
      }
      else {
        JobSubmissionObject[['archivePath']] <- NULL
      }
      if (!is.null(self$`archiveSystem`)) {
        JobSubmissionObject[['archiveSystem']] <- self$`archiveSystem`
      }
      else {
        JobSubmissionObject[['archiveSystem']] <- NULL
      }
      if (!is.null(self$`inputs`)) {
        JobSubmissionObject[['inputs']] <- self$`inputs`
      }
      else {
        JobSubmissionObject[['inputs']] <- NULL
      }
      if (!is.null(self$`name`)) {
        JobSubmissionObject[['name']] <- self$`name`
      }
      else {
        JobSubmissionObject[['name']] <- NULL
      }
      if (!is.null(self$`maxMemory`)) {
        JobSubmissionObject[['maxMemory']] <- self$`maxMemory`
      }
      else {
        JobSubmissionObject[['maxMemory']] <- NULL
      }
      if (!is.null(self$`nodeCount`)) {
        JobSubmissionObject[['nodeCount']] <- self$`nodeCount`
      }
      else {
        JobSubmissionObject[['nodeCount']] <- NULL
      }
      if (!is.null(self$`notifications`)) {
        JobSubmissionObject[['notifications']] <- lapply(self$`notifications`, function(x) x$toJSON())
      }
      else {
        JobSubmissionObject[['notifications']] <- NULL
      }
      if (!is.null(self$`parameters`)) {
        JobSubmissionObject[['parameters']] <- self$`parameters`$toJSON()
      }
      else {
        JobSubmissionObject[['parameters']] <- NULL
      }
      if (!is.null(self$`processorsPerNode`)) {
        JobSubmissionObject[['processorsPerNode']] <- self$`processorsPerNode`
      }
      else {
        JobSubmissionObject[['processorsPerNode']] <- NULL
      }
      if (!is.null(self$`batchQueue`)) {
        JobSubmissionObject[['batchQueue']] <- self$`batchQueue`
      }
      else {
        JobSubmissionObject[['batchQueue']] <- NULL
      }
      if (!is.null(self$`maxRunTime`)) {
        JobSubmissionObject[['maxRunTime']] <- self$`maxRunTime`
      }
      else {
        JobSubmissionObject[['maxRunTime']] <- NULL
      }
      if (!is.null(self$`appId`)) {
        JobSubmissionObject[['appId']] <- self$`appId`
      }
      else {
        JobSubmissionObject[['appId']] <- NULL
      }

      JobSubmissionObject
    },
    fromJSON = function(JobSubmissionObject) {
      if (is.character(JobSubmissionObject)) {
        JobSubmissionObject <- jsonlite::fromJSON(JobSubmissionJson)
      }

      if ("result" %in% names(JobSubmissionObject)) {
        JobSubmissionObject <- JobSubmissionObject$result
      }

      if (!is.null(JobSubmissionObject$`archive`)) {
        self$`archive` <- JobSubmissionObject$`archive`
      }
      if (!is.null(JobSubmissionObject$`archivePath`)) {
        self$`archivePath` <- JobSubmissionObject$`archivePath`
      }
      if (!is.null(JobSubmissionObject$`archiveSystem`)) {
        self$`archiveSystem` <- JobSubmissionObject$`archiveSystem`
      }
      if (!is.null(JobSubmissionObject$`inputs`)) {
        self$`inputs` <- JobSubmissionObject$`inputs`
      }
      if (!is.null(JobSubmissionObject$`name`)) {
        self$`name` <- JobSubmissionObject$`name`
      }
      if (!is.null(JobSubmissionObject$`maxMemory`)) {
        self$`maxMemory` <- JobSubmissionObject$`maxMemory`
      }
      if (!is.null(JobSubmissionObject$`nodeCount`)) {
        self$`nodeCount` <- JobSubmissionObject$`nodeCount`
      }
      if (!is.null(JobSubmissionObject$`notifications`)) {
        self$`notifications` <- lapply(JobSubmissionObject$`notifications`, function(x) {
          notificationsObject <- Notification$new()
          notificationsObject$fromJSON(jsonlite::toJSON(x, auto_unbox = TRUE))
          notificationsObject
        })
      }
      if (!is.null(JobSubmissionObject$`parameters`)) {
        parametersObject <- TODO_OBJECT_MAPPING$new()
        parametersObject$fromJSON(jsonlite::toJSON(JobSubmissionObject$parameters, auto_unbox = TRUE))
        self$`parameters` <- parametersObject
      }
      if (!is.null(JobSubmissionObject$`processorsPerNode`)) {
        self$`processorsPerNode` <- JobSubmissionObject$`processorsPerNode`
      }
      if (!is.null(JobSubmissionObject$`batchQueue`)) {
        self$`batchQueue` <- JobSubmissionObject$`batchQueue`
      }
      if (!is.null(JobSubmissionObject$`maxRunTime`)) {
        self$`maxRunTime` <- JobSubmissionObject$`maxRunTime`
      }
      if (!is.null(JobSubmissionObject$`appId`)) {
        self$`appId` <- JobSubmissionObject$`appId`
      }
    },
    toJSONString = function() {
       sprintf(
        '{
           "archive": %s,
           "archivePath": %s,
           "archiveSystem": %s,
           "inputs": %s,
           "name": %s,
           "maxMemory": %s,
           "nodeCount": %d,
           "notifications": [%s],
           "parameters": %s,
           "processorsPerNode": %d,
           "batchQueue": %s,
           "maxRunTime": %s,
           "appId": %s
        }',
        ifelse( is.null(self$`archive`),"null",paste0(c('"', self$`archive`, '"'))),
        ifelse( is.null(self$`archivePath`),"null",paste0(c('"', self$`archivePath`, '"'))),
        ifelse( is.null(self$`archiveSystem`),"null",paste0(c('"', self$`archiveSystem`, '"'))),
        ifelse( is.null(self$`inputs`),"null",paste0(c('"', self$`inputs`, '"'))),
        ifelse( is.null(self$`name`),"null",paste0(c('"', self$`name`, '"'))),
        ifelse( is.null(self$`maxMemory`),"null",paste0(c('"', self$`maxMemory`, '"'))),
        ifelse( is.null(self$`nodeCount`),"null",paste0(c('"', self$`nodeCount`, '"'))),
        lapply(self$`notifications`, function(x) paste(x$toJSON(), sep=",")),
        self$`parameters`$toJSON(),
        ifelse( is.null(self$`processorsPerNode`),"null",paste0(c('"', self$`processorsPerNode`, '"'))),
        ifelse( is.null(self$`batchQueue`),"null",paste0(c('"', self$`batchQueue`, '"'))),
        ifelse( is.null(self$`maxRunTime`),"null",paste0(c('"', self$`maxRunTime`, '"'))),
        ifelse( is.null(self$`appId`),"null",paste0(c('"', self$`appId`, '"')))
      )
    },
    fromJSONString = function(JobSubmissionJson) {
      JobSubmissionObject <- jsonlite::fromJSON(JobSubmissionJson)
      self::fromJSON(JobSubmissionObject)

    }
  )
)
