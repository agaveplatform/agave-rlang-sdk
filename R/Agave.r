# Agave Platform Science API
# 
# Power your digital lab and reduce the time from theory to discovery using the Agave Science-as-a-Service API Platform. Agave provides hosted services that allow researchers to manage data, conduct experiments, and publish and share results from anywhere at any time.
# 
# OpenAPI spec version: 2.1.11
# 
# Generated by: https://github.com/swagger-api/swagger-codegen.git


#' Agave Class
#'
#' Singleton utility class to ease auth, api client instantiation, and 
#' session management. 
#'
#' NOTE: This class is NOT created as part of the R Swagger client 
#' generation. 
#' 
#' @title Agave API parent class
#' @description rAgave.Agave
#'
#' @field apps AppsAPI instance
#' @field clients = ClientsAPI instance
#' @field jobs = JobsAPI instance
#' @field files = FilesAPI instance
#' @field meta = MetaAPI instance
#' @field monitors = MonitorsAPI instance
#' @field notifications = NotificationsAPI instance
#' @field profiles = ProfilesAPI instance
#' @field systems = SystemsAPI instance
#' @field tags = TagAPI instance
#' @field tenants = TenantsAPI instance
#' @field tokens = TokensAPI instance
#' @field transforms TransformsAPI instance
#' @field uuids UuidsApi instance
#' @field cache Instance of the AgaveCache currently in use
#' @field context The client autentication context
#' @field credentials The active user credentials
#' @field tenant The active tenant
#' @importFrom R6 R6Class
#'
#' @section Methods:
#' \describe{
#'
#' store
#' 
#' restore
#' 
#' 
#' 
#' resolveConfigurationProperty
#'
#' }
#' @export
Agave  <- R6::R6Class(
  'Agave',
  private = list(
    cacheDir = NULL,
    authCache = NULL,
    client = NULL,
    token = NULL,
    tenant = NULL,
    baseUrl = "https://public.agaveapi.co",
    initClientAndAuth = function(accessToken, refreshToken, username, password, clientKey, clientSecret) {
      
      private$token <- private$authCache$getToken();
      private$client <- private$authCache$getClient();
      private$tenant <- private$authCache$getTenant();
      
      private$tenant$baseUrl <- private$baseUrl
      
      # use the provided client key or pull it from the environment or auth cache
      private$client$key <- private$resolveConfigurationProperty(explicitValue = clientKey, configPropertyName = "apikey", envPropertyName = "AGAVE_CLIENT_KEY")
      
      # use the provided client secret or pull it from the environment or auth cache
      private$client$secret <- private$resolveConfigurationProperty(explicitValue = clientSecret, configPropertyName = "apisecret", envPropertyName = "AGAVE_CLIENT_SECRET")
      
      # look for the username of the user in the environment and auth cache. 
      # This will be used for interaction with the clients api and for token generation
      # as well as name resolution for auto-generated templates, etc.
      private$token$username <- private$resolveConfigurationProperty(explicitValue = username, configPropertyName = "username", envPropertyName = "AGAVE_USERNAME")
      
      # look for the password of the user in the environment and auth cache (should not be there). 
      # This will be used for interaction with the clients api and for token generation
      # as well as name resolution for auto-generated templates, etc.
      private$token$password <- private$resolveConfigurationProperty(explicitValue = password, configPropertyName = "password", envPropertyName = "AGAVE_PASSWORD")
      
      # look for an access token explicitly provided for use in all authenticated api calls.
      # If present, this will be used for interaction with the clients api and for token generation
      private$token$access_token <- private$resolveConfigurationProperty(explicitValue = accessToken, configPropertyName = "access_token", envPropertyName = "AGAVE_ACCESS_TOKEN")
      
      # look for a refresh token explicitly provided for use in all authenticated api calls.
      # If present, this will be used to obtain a new access token when th previous one expires
      private$token$refresh_token <- private$resolveConfigurationProperty(explicitValue = refreshToken, configPropertyName = "refresh_token", envPropertyName = "AGAVE_REFRESH_TOKEN")
    },
    
    initResources = function() {
      
      # tenants api has no auth
      self$tenants <- TenantsApi$new() 
      
      # init the ClientsApi api client with basic auth using the user's u/p
      if (!is.null(private$token) && !is.null(private$token$username) && !is.null(private$token$password)) { 
        base64Hash <- jsonlite::base64_enc(paste(c(private$token$username,":",private$token$password), collapse=""))
        self$clients <- ClientsApi$new(ApiClient$new(basePath = private$baseUrl, defaultHeaders = c(Authorization = paste(c("Basic", base64Hash), collapse = " "))), cache = private$authCache)
      }
      # Null it out if no user credentials are set
      else {
        self$clients = NULL
      }
      
      # init the TokensApi api client with basic auth using the client key and secret
      if (!is.null(private$client) && !is.null(private$client$key) && !is.null(private$client$secret)) { 
        base64Hash <- jsonlite::base64_enc(paste(c(private$client$key,":",private$client$secret), collapse=""))
        self$tokens <- TokensApi$new(ApiClient$new(basePath = private$baseUrl, 
                                                  defaultHeaders = c(Authorization = paste(c("Basic", base64Hash), collapse = " "))), 
                                     client = private$client, 
                                     username = private$token$username, 
                                     password = private$token$password,
                                     cache = private$authCache)
        
        # refresh the token so they're ready to geaux
       logger.debug("Before initial check of auth cache")
       # logger.debug(str(private$token$toJSON()))
            
        resp <- NULL
        if (!is.null(private$token$refresh_token)) { 
          resp <- self$tokens$refresh(refreshToken = private$token$refresh_token)
          if ("access_token" %in% names(resp)) {
            #logger.trace("After call to refresh token")
            #logger.trace(str(resp))
            token <- Token$new()
            token$fromJSON(resp)
            #logger.trace("After marshalling to object")
            #logger.trace(token$toJSONString())
            token$username <- private$token$username
            token$password <- private$token$password
            token$created_at <- format(Sys.time(), "%a %b %d %H:%M:%S %Y")
            token$expires_at <- format(Sys.time() + token$expires_in, "%a %b %d %H:%M:%S %Y")
            private$token <- token
            logger.trace("After refresh token initialization")
            # logger.trace(str(private$token$toJSON()))
            
            private$authCache$setToken(private$token)
            logger.info("Successfully refreshed the existing token")
          }
          else {
            # leave it be
            logger.warn("Failed to refresh token \n%s", httr::content(resp$response, "text", encoding = "UTF-8"))
            resp <- NULL
            
          }
          
        }
        # or pull a fresh token
        if (is.null(resp) && !is.null(private$token$username) && !is.null(private$token$password)) {
          resp <- self$tokens$create()
          if ("access_token" %in% names(resp)) {
            #logger.trace("After call to create token")
            #logger.trace(str(resp))
            token <- Token$new()
            token$fromJSON(resp)
            #logger.trace("After marshalling to object")
            #logger.trace(token$toJSONString())
            token$username <- private$token$username
            token$password <- private$token$password
            token$created_at <- format(Sys.time(), "%a %b %d %H:%M:%S %Y")
            token$expires_at <- format(Sys.time() + token$expires_in, "%a %b %d %H:%M:%S %Y")
            private$token <- token
            #logger.trace("After new token initialization")
            #logger.trace(private$token$toJSONString())
            private$authCache$setToken(private$token)
            logger.info("Successfully obtained a fresh token")
          }
          else {
           # leave it be
            #logger.debug("Failed to create new token \n%s", httr::content(resp$response, "text", encoding = "UTF-8"))
            
          }
        }
        else if (is.null(resp)) {
          # nothing to do. they're not going to be able to auth any requests
          #logger.info("Unable to obtain a fresh token")
        }
      }
      # Null it out if no client credentials are present
      else {
        self$tokens <- NULL
        #logger.warn("Unable to obtain a fresh token. No client credentials were found.")
      }
      
      if (!is.null(private$token$access_token)) {
        # generate an api client for oauth2 authorization using the private$token$access_token previously
        # initialized
        oauthApiClient <- ApiClient$new(basePath = private$baseUrl, 
                                        defaultHeaders = c(Authorization = paste("Bearer", private$token$access_token)))
        
        # init the remaining apis using bearer token auth
        self$apps <- AppsApi$new(oauthApiClient) 
        self$meta <- MetaApi$new(oauthApiClient) 
        self$profiles <- ProfilesApi$new(oauthApiClient) 
        self$transforms <- TransformsApi$new(oauthApiClient) 
        self$jobs <- JobsApi$new(oauthApiClient) 
        self$files <- FilesApi$new(oauthApiClient) 
        self$monitors <- MonitorsApi$new(oauthApiClient) 
        self$systems <- SystemsApi$new(oauthApiClient) 
        self$uuids <- UuidsApi$new(oauthApiClient) 
        self$tags <- TagApi$new(oauthApiClient) 
        self$notifications <- NotificationsApi$new(oauthApiClient) 
      }
      # NULL out all oauth apis if no acces token is available
      else {
        self$apps <- NULL
        self$meta <- NULL
        self$profiles <- NULL
        self$transforms <- NULL
        self$jobs <- NULL
        self$files <- NULL
        self$monitors <- NULL
        self$systems <- NULL
        self$uuids <- NULL
        self$tags <- NULL
        self$notifications <- NULL
      }
    },
    
    resolveConfigurationProperty = function(explicitValue, configPropertyName, envPropertyName) {
      
      val <- NULL
      if (!missing(explicitValue) && !is.null(explicitValue) && nchar(explicitValue) > 1) {
        val <- explicitValue
      }

      if ((is.null(val) || nchar(val) == 0) && !missing(envPropertyName) && !is.null(envPropertyName)) {
        val <- Sys.getenv(envPropertyName)
      }

      if ((is.null(val) || nchar(val) == 0) && !missing(configPropertyName) && !is.null(configPropertyName)) {
        val <- private$authCache$getProperty(configPropertyName)
      }

      val
    }
  ),
  public = list(
    apps = NULL,
    clients = NULL,
    jobs = NULL,
    files = NULL,
    meta = NULL,
    monitors = NULL,
    notifications = NULL,
    profiles = NULL,
    systems = NULL,
    tags = NULL,
    tenants = NULL,
    tokens = NULL,
    transforms = NULL,
    uuids = NULL,
    initialize = function(baseUrl, cacheDir, username, password, clientKey, clientSecret, accessToken, refreshToken, logLevel=FATAL, logFile="agave.log"){
      
      if (missing(logFile)) {
        logFile = paste0(c(getwd(),"agave.log"), collapse = .Platform$file.sep)
      }
      
      if (!file.exists(logFile)) {
        file.create(logFile)
      }
      
      logger.setup(debugLog = logFile, infoLog = logFile, warnLog = logFile, errorLog = logFile, fatalLog = logFile, traceLog = logFile)
      
      if (!missing(logLevel)) {
        logger.setLevel(logLevel)
      }
      
      
      # init the auth cache object to manage our tenant, client, and credential cache
      if (!missing(cacheDir)){
        private$cacheDir <- cacheDir
        private$authCache <- AgaveCache$new(private$authCache)
      }
      else {
        private$authCache <- AgaveCache$new()
      }
     
      # use the given API Base url if provided
      if (!missing(baseUrl) && nchar(baseUrl) > 0) {
        private$baseUrl <- baseUrl
      }
      # lookup from the auth cache if not provided, othewise, we use the public tenant
      else if (! is.null(private$authCache$baseurl)) {
        private$baseUrl <- private$authCache$baseurl
      }
      
      if (missing(username)) {username = NULL}
      if (missing(password)) {password = NULL}
      if (missing(clientKey)) {clientKey = NULL}
      if (missing(clientSecret)) {clientSecret = NULL}
      if (missing(accessToken)) {accessToken = NULL}
      if (missing(refreshToken)) {refreshToken = NULL}

      # set the user token using the passed in values. If an access token is
      # passed in, that is enough. A refresh
      private$initClientAndAuth(accessToken, refreshToken, username, password, clientKey, clientSecret)
      
      private$initResources()
    },
    
    restore = function(client, token, tenant) {
      
      if (!missing(token)) {
        private$token = token
      }
      
      if (!missing(client)) {
        private$client = client
      }
      
      if (!missing(tenant)) {
        private$tenant = tenant
      }
      
      private$initResources()
    },
    
    store = function() {
      private$authCache$setToken(private$token)
      private$authCache$setClient(private$client)
      private$authCache$setTenant(private$tenant)
      private$authCache$write();
    }
  ),
  active = list(
    cache = function(value) {
      private$authCache$current
    },
    tenantInfo = function(value) {
      private$tenant$toJSON()
    },
    tokenInfo = function(value) {
      private$token
    },
    clientInfo = function(value) {
      private$client$toJSON()
    },
    authCheck = function(value) {
      # store the current session to disk to ensure
      # the cache is up to date
      self$store()
     
      # force the cache to reread
      private$authCache$load()
      
      # now dump the cache info
      private$authCache$current
    },
    logLevel = function(value) {
      logger.setLevel(value)
    }
  )
)